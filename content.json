{"meta":{"title":"Yang's Blog","subtitle":"如果你无法简洁的表达你的想法,只能证明你还不够了解它~","description":"read,think,share","author":"Amose  Yang","url":"amosewarrior.github.io"},"pages":[],"posts":[{"title":"lombok之插件安装(idea版)","slug":"lombok1","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T04:04:45.432Z","comments":true,"path":"20180420/lombok1/","link":"","permalink":"amosewarrior.github.io/20180420/lombok1/","excerpt":"","text":"一.主题简介&emsp;&emsp;lombok是一个通过注解来减少模板代码的插件,其作用于编译期,网上都是这么说的:就是源代码在编译成字节码的时候修改了语法树的节点规则进行了加强生成.在我的理解就是在编译的时候将被注解的地方生成对应注解的模板代码.就跟代码生成器一样,只不过lombok生成的是字节码,我们生成的是java源码.介绍到这,我们开始安装~ 二.安装插件&emsp;&emsp;找到配置下的插件管理器,点击插件仓库搜索lombok进行安装:File-&gt;Settings-&gt;Plugins 三.配置&emsp;&emsp;配置编译器的属性,勾选使用注解处理,然后重启idea.File-&gt;Settings-&gt;Build-&gt;Compiler-&gt;Annotation Processors 四.踩坑检测&emsp;&emsp;在安装插件的时候踩了两个坑.坑1:编译器使用的Eclipse,导致lombok插件无法使用.改成javac,并去掉使用模块的jdk选项坑2:若要使用lombok.config配置参数.请不要放在resources文件夹下,放在src包下,不然编译无法时是读取不到的. 五.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"SpringBoot之Restful Web Service","slug":"springboot2","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T04:03:01.921Z","comments":true,"path":"20180420/springboot2/","link":"","permalink":"amosewarrior.github.io/20180420/springboot2/","excerpt":"","text":"&emsp;&emsp;用maven+springboot搭建一个简单的restful web service. 一.目标:在这里会创建一个服务,接收如下请求1http://localhost:8080/greeting 并返回如下的json对象.1&#123;&quot;id&quot;:&quot;1&quot;,&quot;content&quot;:&quot;Hello World&quot;&#125; 当然,在上面请求中,我们也可以添加参数1http://localhost:8080/greeting?name=yang 然后返回结果为1&#123;&quot;id&quot;:&quot;1&quot;,&quot;content&quot;:&quot;Hello yang&quot;&#125; 二.maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 三.构建服务1.bean&emsp;&emsp;利用json工具自动将Greeting类转为json123456789101112131415161718192021package com.amose.bean;public class Greeting &#123; private String id; private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 2.restful接口类123456789101112131415161718192021package com.amose.controller;import com.amose.bean.Greeting;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicLong;@RestControllerpublic class GreetingController &#123; private static final String template = &quot;Hello, %s!&quot;; private final AtomicLong counter = new AtomicLong(); @RequestMapping(&quot;/greeting&quot;) public Greeting greeting(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;) String name)&#123; Greeting g = new Greeting(); g.setId(counter.getAndIncrement()); g.setContent(String.format(template,name)); return g; &#125;&#125; 3.springboot 启动类&emsp;&emsp;需要注意的是:启动类请放在com.amose目录下.1234567891011package com.amose;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class T1SpringBootApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(T1SpringBootApplication.class,args); &#125;&#125; 四.结果 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之SocialConfigurerAdapter.class cannot be opened because it does not exist","slug":"springboot1","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T04:03:06.811Z","comments":true,"path":"20180420/springboot1/","link":"","permalink":"amosewarrior.github.io/20180420/springboot1/","excerpt":"","text":"&emsp;&emsp;用maven搭建了一个springboot的小demo,然后在启动是报如下错误:1234567891011121314151617Caused by: java.io.FileNotFoundException: class path resource [org/springframework/social/config/annotation/SocialConfigurerAdapter.class] cannot be opened because it does not exist at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:172) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReader.&lt;init&gt;(SimpleMetadataReader.java:50) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:98) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.createMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:89) ~[spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE] at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.getMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:76) ~[spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:93) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.asSourceClass(ConfigurationClassParser.java:693) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getSuperClass(ConfigurationClassParser.java:857) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:328) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:190) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:292) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:198) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:167) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] ... 13 common frames omitted 找了半天,发现前面有个警告. 发现是启动类不应该放在在顶级包下.然后加了个包就行了.","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之Unsupported major.minor version 52.0(idea版)","slug":"springboot3","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T03:54:12.647Z","comments":true,"path":"20180420/springboot3/","link":"","permalink":"amosewarrior.github.io/20180420/springboot3/","excerpt":"","text":"&emsp;&emsp;在进行springboot demo启动时,出现了Unsupported major.minor version 52.0 的错误.这是因为springboot的需求版本跟java的目标版本不一致.共需要修改两个地方.","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"lombok之注解使用","slug":"lombok2","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T04:04:59.547Z","comments":true,"path":"20180420/lombok2/","link":"","permalink":"amosewarrior.github.io/20180420/lombok2/","excerpt":"","text":"一.lombok对象与注解&emsp;&emsp;lombok 通过注解和定义对象来简化代码的书写.比如val 用于定义局部finnal变量.var 用于定义局部动态变量.@NonNull 进行非空判断. 二.demo的依赖包&emsp;&emsp;使用lombok时除了要使用lombok插件外还需要添加lombok的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.12&lt;/version&gt;&lt;/dependency&gt; 三.val 局部finally变量&emsp;&emsp; 利用val替代实际final变量的声明,让lombok自动根据赋值表达式来替换val.替换的好处就是不需要自己判定赋值表达式返回的数据类型,当然源代码长度也缩减了. lombok的目的也就是为了减少冗余代码.1234567891011121314151617import lombok.val;import java.util.ArrayList;/** * @author yp * @time 2018/4/13 * @description 可以用val替代局部final变量的实际声明.由val代替的声明 */public class TestVal &#123; public static void main(String[] args)&#123; val list = new ArrayList&lt;String&gt;(); //等同于ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"0\"); list.add(\"1\"); System.out.println(list.get(0)); list = new ArrayList&lt;String&gt;(); &#125;&#125; 四.var 局部变量&emsp;&emsp; var这个对象其实目前还处于实验阶段,所以在使用var时需要注意,需要现在lombok.config中声明: lombok.var.flagUsage = ALLOW &emsp;&emsp; 这样lombok插件才会去读取由var标注的变量,并进行转换.123456789101112131415161718import lombok.experimental.var;import java.util.ArrayList;/** * @author yp * @time 2018/4/16 * @description */public class TestVar &#123; public static void main(String[] args)&#123; var s = new ArrayList&lt;String&gt;(); s.add(\"aaa\"); s.add(\"bbb\"); System.out.println(\"==&gt;\"+s.get(0)); s = new ArrayList&lt;String&gt;(); s.add(\"cccc\"); System.out.println(\"==&gt;\"+s.get(0)); &#125;&#125; &emsp;&emsp; 这里需要注意的是,请将lombok.config放在src下,而不是resources下,编译优于合并. 五.@NonNull 注解&emsp;&emsp; 在构造方法或者放入入参时,在所有方法体代码内的顶层进行对参数进行null判断(但是,super()和this()会比它先执行).1234567891011121314151617181920212223242526272829303132333435363738394041424344import lombok.NonNull;/** * @author yp * @time 2018/4/20 * @description */public class TestNonNull extends Something&#123; public TestNonNull(@NonNull String s) &#123; super(\"Hello1\"); System.out.println(s); &#125; private TestNonNull(Integer s) &#123; super(\"Hello2\"); if(s == null)&#123; throw new NullPointerException(\"normal\"); &#125; System.out.println(s); &#125; public static void main(String[] args)&#123; String s = null; TestNonNull t1 = new TestNonNull(s); Integer a = null; TestNonNull t2 = new TestNonNull(a); &#125;&#125;/** * @author yp * @time 2018/4/20 * @description */public class Something &#123; public Something(String s)&#123; System.out.println(s); &#125; public Something(Integer s)&#123; System.out.println(s); &#125;&#125; 从代码和上图可以看出,@NonNull 是在构造方法的super()方法之后进行null检查的,跟if(s == null)效果一致. 六.@Cleanup 资源释放&emsp;&emsp;@Cleanup是用来对局部变量所占用的资源进行自动释放的.比如输入,输出流.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.Cleanup;import java.io.*;/** * @author yp * @time 2018/4/23 * @description Cleanup 用于自动结束使用的资源. */public class TestCleanUp &#123; public static void main(String[] args) throws IOException &#123; String[] s = new String[2]; s[0] = &quot;D:/SQLWork.txt&quot;; s[1] = &quot;D:/SQLWork1.txt&quot;; File file = new File(s[1]); //在执行main1的时候,没有进行流的关闭,文件会被占用,这里进行删除操作会返回false main1(s); boolean d1 = file.delete(); System.out.println(&quot;无Cleanup注解===&gt;&quot;+d1); //在执行main2方法时,请注释main1的代码,避免main1的流未关闭造成文件被占用 //在执行main2的时候,通过Cleanup进行流的关闭,这里进行删除操作会返回true main2(s); boolean d2= file.delete(); System.out.println(&quot;有Cleanup注解===&gt;&quot;+d2); &#125; public static void main1(String[] args) throws IOException &#123; InputStream in = new FileInputStream(args[0]); OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125; public static void main2(String[] args) throws IOException &#123; @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125;&#125; 七.@Getter@Setter 1.@Getter @Setter可以放在类上,对类的成员变量进行get,set方法的生成,也可以放在指定成员变量上.123456789import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private String username; private String password;&#125; 2.通过AccessLevel设定成员变量生成的Get和set方法的访问级别,PUBLIC, PROTECTED, PACKAGE,PRIVATE123456789import lombok.AccessLevel;import lombok.Getter;public class User1 &#123; @Getter(AccessLevel.PROTECTED)// private String username; @Getter(AccessLevel.NONE)//禁止get,set方法生成 private String password;&#125; 八.@ToString 生成toString方法&emsp;&emsp;类上添加@ToString方法,进行toString方法的生成,通过exclude=””来进行指定属性的排除123456789101112131415161718import lombok.Getter;import lombok.Setter;import lombok.ToString;/** * @author yp * @time 2018/4/23 * @description */@ToString(exclude = &quot;password&quot;)@Getter@Setterpublic class User3 &#123; private String username; private String password; private String sex;&#125; 九.@EqualsAndHashCode&emsp;&emsp;重写equal和hashcode 方法.通过exclude={“id”, “shape”}来排除指定属性.通过callSuper=true来对父类成员变量的生成.12345678910111213141516171819202122232425import lombok.EqualsAndHashCode;@EqualsAndHashCode(exclude=&#123;&quot;id&quot;, &quot;shape&quot;&#125;)public class EqualsAndHashCodeExample &#123; private transient int transientVar = 10; private String name; private double score; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() &#123; return this.name; &#125; @EqualsAndHashCode(callSuper=true) public static class Square extends Shape &#123; private final int width, height; public Square(int width, int height) &#123; this.width = width; this.height = height; &#125; &#125;&#125; 十.构造注解&emsp;&emsp;@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor 分别是:无参构造,指定有参构造(被@NonNull标记),所有构造1234567891011121314151617import lombok.AccessLevel;import lombok.RequiredArgsConstructor;import lombok.AllArgsConstructor;import lombok.NonNull;@RequiredArgsConstructor(staticName = &quot;of&quot;)@AllArgsConstructor(access = AccessLevel.PROTECTED)public class ConstructorExample&lt;T&gt; &#123; private int x, y; @NonNull private T description; @NoArgsConstructor public static class NoArgsExample &#123; @NonNull private String field; &#125;&#125;` 十一.@Data&emsp;&emsp;是@ToString, @EqualsAndHashCode, @Getter 所有属性, @Setter 所有非final属性,和@RequiredArgsConstructor的合集,lombok中最为常用的注解. 十二.@Value&emsp;&emsp;@Value 是@Data的final类,属性也是final的.当然用@Wither注解的属性不是final的.1234567891011121314151617181920 import lombok.AccessLevel;import lombok.experimental.NonFinal;import lombok.experimental.Value;import lombok.experimental.Wither;import lombok.ToString;@Value public class ValueExample &#123; String name; @Wither(AccessLevel.PACKAGE) @NonFinal int age; double score; protected String[] tags; @ToString(includeFieldNames=true) @Value(staticConstructor=&quot;of&quot;) public static class Exercise&lt;T&gt; &#123; String name; T value; &#125;&#125; 十三.@Log通过不同的注解生成不同类型的log变量.这个在lombok中也是比较实用的1234567891011121314@CommonsLogCreates private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);@JBossLogCreates private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);@LogCreates private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());@Log4jCreates private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);@Log4j2Creates private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);@Slf4jCreates private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);@XSlf4jCreates private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 1234567891011121314151617181920212223@Logpublic class LogExample &#123; public static void main(String... args) &#123; log.error(&quot;Something&apos;s wrong here&quot;); &#125;&#125;@Slf4jpublic class LogExampleOther &#123; public static void main(String... args) &#123; log.error(&quot;Something else is wrong here&quot;); &#125;&#125;@CommonsLog(topic=&quot;CounterLog&quot;)public class LogExampleCategory &#123; public static void main(String... args) &#123; log.error(&quot;Calling the &apos;CounterLog&apos; with a message&quot;); &#125;&#125; 十四.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-18T00:55:29.125Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"20180418/hello-world/","link":"","permalink":"amosewarrior.github.io/20180418/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
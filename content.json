{"meta":{"title":"Yang's Blog","subtitle":"如果你无法简洁的表达你的想法,只能证明你还不够了解它~","description":"read,think,share","author":"Amose  Yang","url":"amosewarrior.github.io"},"pages":[],"posts":[{"title":"lombok之插件安装(idea版)","slug":"lombok1","date":"2018-04-20T03:13:18.000Z","updated":"2018-04-20T04:02:14.227Z","comments":true,"path":"20180420/lombok1/","link":"","permalink":"amosewarrior.github.io/20180420/lombok1/","excerpt":"","text":"一.主题简介&emsp;&emsp;lombok是一个通过注解来减少模板代码的插件,其作用于编译期,网上都是这么说的:就是源代码在编译成字节码的时候修改了语法树的节点规则进行了加强生成.在我的理解就是在编译的时候将被注解的地方生成对应注解的模板代码.就跟代码生成器一样,只不过lombok生成的是字节码,我们生成的是java源码.介绍到这,我们开始安装~ 二.安装插件&emsp;&emsp;找到配置下的插件管理器,点击插件仓库搜索lombok进行安装:File-&gt;Settings-&gt;Plugins 三.配置&emsp;&emsp;配置编译器的属性,勾选使用注解处理,然后重启idea.File-&gt;Settings-&gt;Build-&gt;Compiler-&gt;Annotation Processors 四.踩坑检测&emsp;&emsp;在安装插件的时候踩了两个坑.坑1:编译器使用的Eclipse,导致lombok插件无法使用.改成javac,并去掉使用模块的jdk选项坑2:若要使用lombok.config配置参数.请不要放在resources文件夹下,放在src包下,不然编译无法时是读取不到的. 五.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"lombok之注解使用","slug":"lombok2","date":"2018-04-20T03:13:18.000Z","updated":"2018-04-23T06:50:40.606Z","comments":true,"path":"20180420/lombok2/","link":"","permalink":"amosewarrior.github.io/20180420/lombok2/","excerpt":"","text":"一.lombok对象与注解&emsp;&emsp;lombok 通过注解和定义对象来简化代码的书写.比如val 用于定义局部finnal变量.var 用于定义局部动态变量.@NonNull 进行非空判断. 二.demo的依赖包&emsp;&emsp;使用lombok时除了要使用lombok插件外还需要添加lombok的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.12&lt;/version&gt;&lt;/dependency&gt; 三.val 局部finally变量&emsp;&emsp; 利用val替代实际final变量的声明,让lombok自动根据赋值表达式来替换val.替换的好处就是不需要自己判定赋值表达式返回的数据类型,当然源代码长度也缩减了. lombok的目的也就是为了减少冗余代码.1234567891011121314151617import lombok.val;import java.util.ArrayList;/** * @author yp * @time 2018/4/13 * @description 可以用val替代局部final变量的实际声明.由val代替的声明 */public class TestVal &#123; public static void main(String[] args)&#123; val list = new ArrayList&lt;String&gt;(); //等同于ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"0\"); list.add(\"1\"); System.out.println(list.get(0)); list = new ArrayList&lt;String&gt;(); &#125;&#125; 四.var 局部变量&emsp;&emsp; var这个对象其实目前还处于实验阶段,所以在使用var时需要注意,需要现在lombok.config中声明: lombok.var.flagUsage = ALLOW &emsp;&emsp; 这样lombok插件才会去读取由var标注的变量,并进行转换.123456789101112131415161718import lombok.experimental.var;import java.util.ArrayList;/** * @author yp * @time 2018/4/16 * @description */public class TestVar &#123; public static void main(String[] args)&#123; var s = new ArrayList&lt;String&gt;(); s.add(\"aaa\"); s.add(\"bbb\"); System.out.println(\"==&gt;\"+s.get(0)); s = new ArrayList&lt;String&gt;(); s.add(\"cccc\"); System.out.println(\"==&gt;\"+s.get(0)); &#125;&#125; &emsp;&emsp; 这里需要注意的是,请将lombok.config放在src下,而不是resources下,编译优于合并. 五.@NonNull 注解&emsp;&emsp; 在构造方法或者放入入参时,在所有方法体代码内的顶层进行对参数进行null判断(但是,super()和this()会比它先执行).1234567891011121314151617181920212223242526272829303132333435363738394041424344import lombok.NonNull;/** * @author yp * @time 2018/4/20 * @description */public class TestNonNull extends Something&#123; public TestNonNull(@NonNull String s) &#123; super(\"Hello1\"); System.out.println(s); &#125; private TestNonNull(Integer s) &#123; super(\"Hello2\"); if(s == null)&#123; throw new NullPointerException(\"normal\"); &#125; System.out.println(s); &#125; public static void main(String[] args)&#123; String s = null; TestNonNull t1 = new TestNonNull(s); Integer a = null; TestNonNull t2 = new TestNonNull(a); &#125;&#125;/** * @author yp * @time 2018/4/20 * @description */public class Something &#123; public Something(String s)&#123; System.out.println(s); &#125; public Something(Integer s)&#123; System.out.println(s); &#125;&#125; 从代码和上图可以看出,@NonNull 是在构造方法的super()方法之后进行null检查的,跟if(s == null)效果一致. 六.@Cleanup 资源释放&emsp;&emsp;@Cleanup是用来对局部变量所占用的资源进行自动释放的.比如输入,输出流.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.Cleanup;import java.io.*;/** * @author yp * @time 2018/4/23 * @description Cleanup 用于自动结束使用的资源. */public class TestCleanUp &#123; public static void main(String[] args) throws IOException &#123; String[] s = new String[2]; s[0] = &quot;D:/SQLWork.txt&quot;; s[1] = &quot;D:/SQLWork1.txt&quot;; File file = new File(s[1]); //在执行main1的时候,没有进行流的关闭,文件会被占用,这里进行删除操作会返回false main1(s); boolean d1 = file.delete(); System.out.println(&quot;无Cleanup注解===&gt;&quot;+d1); //在执行main2方法时,请注释main1的代码,避免main1的流未关闭造成文件被占用 //在执行main2的时候,通过Cleanup进行流的关闭,这里进行删除操作会返回true main2(s); boolean d2= file.delete(); System.out.println(&quot;有Cleanup注解===&gt;&quot;+d2); &#125; public static void main1(String[] args) throws IOException &#123; InputStream in = new FileInputStream(args[0]); OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125; public static void main2(String[] args) throws IOException &#123; @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125;&#125; 七.@Getter@Setter自动生成get,set方法 1.@Getter @Setter可以放在类上,对类的成员变量进行get,set方法的生成,也可以放在指定成员变量上.123456789import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private String username; private String password;&#125; 2.通过AccessLevel设定成员变量生成的Get和set方法的访问级别,PUBLIC, PROTECTED, PACKAGE,PRIVATE123456789import lombok.AccessLevel;import lombok.Getter;public class User1 &#123; @Getter(AccessLevel.PROTECTED)// private String username; @Getter(AccessLevel.NONE)//禁止get,set方法生成 private String password;&#125; 八.@ToString 生成toString方法&emsp;&emsp;类上添加@ToString方法,进行toString方法的生成,通过exclude=””来进行指定属性的排除123456789101112131415161718import lombok.Getter;import lombok.Setter;import lombok.ToString;/** * @author yp * @time 2018/4/23 * @description */@ToString(exclude = &quot;password&quot;)@Getter@Setterpublic class User3 &#123; private String username; private String password; private String sex;&#125; 五.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-18T00:55:29.125Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"20180418/hello-world/","link":"","permalink":"amosewarrior.github.io/20180418/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
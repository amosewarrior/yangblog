{"meta":{"title":"Yang's Blog","subtitle":"如果你无法简洁的表达你的想法,只能证明你还不够了解它~","description":"read,think,share","author":"Amose  Yang","url":"amosewarrior.github.io"},"pages":[],"posts":[{"title":"volatile关键字","slug":"volatile","date":"2018-06-18T15:36:18.000Z","updated":"2018-06-19T04:25:11.289Z","comments":true,"path":"20180618/volatile/","link":"","permalink":"amosewarrior.github.io/20180618/volatile/","excerpt":"","text":"&emsp;&emsp;本篇中,简要的说一下自己对volatile的理解 一.内存模型:&emsp;&emsp;在JMM中,存在一个主存,所有的变量都是存在主存中,对所有的线程共享,而线程对于数据的操作是在工作内存中.每个工作内存中的数据都是对主存中数据的拷贝,线程之间无法互相访问,传递值都需要通过主存完成. ####1.JMM中为啥需要工作内存&emsp;&emsp;现在的计算机，cpu在计算的时候，并不总是从内存读取数据，它的数据读取顺序优先级 是：寄存器－高速缓存－内存。线程耗费的是CPU，线程计算的时候，原始的数据来自内存，在计算过程中，有些数据可能被频繁读取，这些数据被存储在寄存器和高速缓存中，当线程计算完后，这些缓存的数据在适当的时候应该写回内存。所以,JVM会将内存中的变量拷贝副本到工作内存中,然后再进行操作. ####2.工作内存造成的问题多CPU并行读写某个共享变量时,由于操作是在主存中,所以会出现线程并发安全问题. ####3.工作内存与主存的交互协议缓存一致性协议:MESI协议,用于保证缓存的一致性.即当CPU缓存中被缓存的共享变量被修改后进行写数据时,其他CPU缓存中的副本就会变成invalid失效的,然后要在缓存中读取数据到cpu执行引擎中时就会去内存中重新拷贝副本到工作内存中.保证各缓存中M:缓存中数据被修改E:只有一个缓存汇总有该数据S:多个缓存中都有该数据I:当该缓存中的数据再其他缓存中被修改后,该缓存中的数据就不可用了. ####4.主存与工作内存中的8个原子性步骤lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态unlock（解锁）：作用于主内存的变量，释放锁定状态的变量read（读取）：作用于主内存的变量，把一个变量从主内存传输到线程的工作内存中，以便随后的load动作使用load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作assign（赋值）：作用于工作内存的变量，把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作store（存储）：作用于工作内存的变量，把工作内存的一个变量值传送到主内存，以便随后的write操作使用write（写入）：作用于主内存的变量，把store操作从工作内存得到的变量的值放入主内存变量中。 二.并发编程三大特性####1.原子性&emsp;&emsp;原子性是指一个原子操作在cpu中不可以暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。原子操作保证了原子性问题。在java内存模型中,read与load assign和store必须成对出现,这样保证了对基础数据的读取和赋值操作是原子性的.在java中我们可以通过synchronized,Lock,volatile+cas保证原子性 ####2.有序性&emsp;&emsp; ####3.可见性: &emsp;&emsp;java 内存模型的主内存和工作内存，解决了可见性问题。&emsp;&emsp;volatile赋予了变量可见——禁止编译器对成员变量进行优化，它修饰的成员变量在每次被线程访问时，都强迫从内存中重读该成员变量的值；而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存，这样在任何时刻两个不同线程总是看到某一成员变量的同一个值，这就是保证了可见性。普通变量是无法保证的. 四.volatile如何保证有序性写volatile的时候生成汇编码是 lock addl $0x0, (%rsp), 在写操作之前使用了lock前缀，锁住了总线和对应的地址，这样其他的写和读都要等待锁的释放。当写完成后，释放锁，把缓存刷新到主内存。 读volatile就很好理解了，不需要额外的汇编指令，CPU发现对应地址的缓存被锁了，等待锁的释放，缓存一致性协议会保证它读到最新的值。 只需要对写volatile的使用用lock对总线加锁就行了，这样其他的读、写操作等待总线释放才能继续读。Lock会让其他CPU的缓存invalide，从内存重新加载数据。 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"同步与并发","slug":"同步与并发","permalink":"amosewarrior.github.io/categories/同步与并发/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"}]},{"title":"SpringBoot之文件上传下载","slug":"springboot9","date":"2018-05-15T08:13:18.000Z","updated":"2018-05-15T06:16:44.417Z","comments":true,"path":"20180515/springboot9/","link":"","permalink":"amosewarrior.github.io/20180515/springboot9/","excerpt":"","text":"&emsp;&emsp;本篇中,使用H2存储文件上传日志,thymeleaf作为视图模板引擎实现文件上传与下载. 一.目标:1.文件上传到指定位置(d:/temp/)2.已上传文件展现3.文件下载 二.maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.amose&lt;/groupId&gt; &lt;artifactId&gt;spring-upload&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-upload&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jdbc依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--H2 java内置数据库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 三.构建服务1.文件上传下载处理控制器&emsp;&emsp;用来接收页面,文件上传,文件列表,文件下载等请求并处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.amose.springupload.controller;import com.amose.springupload.exception.StorageFileNotFoundException;import com.amose.springupload.service.StorageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.Resource;import org.springframework.http.HttpHeaders;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;import org.springframework.web.servlet.mvc.support.RedirectAttributes;import java.util.stream.Collectors;@Controllerpublic class UploadFileController &#123; private final StorageService storageService; @Autowired public UploadFileController(StorageService storageService) &#123; this.storageService = storageService; &#125; @GetMapping(\"/\")//获取已上传文件列表 public String listUploadedFiles(Model model) &#123; model.addAttribute(\"files\", storageService.loadAll().map( path -&gt; MvcUriComponentsBuilder.fromMethodName(UploadFileController.class, \"serveFile\", path.getFileName().toString()).build().toString()) .collect(Collectors.toList())); return \"uploadForm\"; &#125; @GetMapping(\"/files/&#123;filename:.+&#125;\") @ResponseBody//下载指定文件名的文件 public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) &#123; Resource file = storageService.loadAsResource(filename); return ResponseEntity.ok().header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + file.getFilename() + \"\\\"\").body(file); &#125; @PostMapping(\"/\")//单文件上传 public String handleFileUpload(@RequestParam(\"file\") MultipartFile file, RedirectAttributes redirectAttributes) &#123; storageService.store(file); redirectAttributes.addFlashAttribute(\"message\", \"You successfully uploaded \" + file.getOriginalFilename() + \"!\"); return \"redirect:/\"; &#125; @ExceptionHandler(StorageFileNotFoundException.class)//指定异常处理类 public ResponseEntity&lt;?&gt; handleStorageFileNotFound(StorageFileNotFoundException exc) &#123; return ResponseEntity.notFound().build(); &#125;&#125; 2.业务接口1234567891011121314151617181920package com.amose.springupload.service;import org.springframework.core.io.Resource;import org.springframework.web.multipart.MultipartFile;import java.nio.file.Path;import java.util.stream.Stream;public interface StorageService &#123; void init(); void store(MultipartFile file); Stream&lt;Path&gt; loadAll(); Path load(String filename); Resource loadAsResource(String filename); void deleteAll();&#125; 3.业务简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.amose.springupload.service.impl;import com.amose.springupload.exception.StorageFileNotFoundException;import com.amose.springupload.service.StorageService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.net.URI;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Date;import java.util.List;import java.util.stream.Stream;@Servicepublic class StorageServiceImpl implements StorageService &#123; @Autowired JdbcTemplate jdbcTemplate; @Value(\"$&#123;spring.servlet.multipart.location&#125;\") private String rootPath; @Override public void init() &#123; //文件系统初始化 File dir = new File(rootPath); if(!dir.exists())&#123; dir.mkdir(); &#125; &#125; @Override public void store(MultipartFile file)&#123; File f = new File(rootPath+file.getOriginalFilename()); try &#123; file.transferTo(f); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; jdbcTemplate.update(\"insert into file_log(file_name,add_time) values (?,?)\",new Object[]&#123;file.getOriginalFilename(),new Date()&#125;); &#125; @Override public Stream&lt;Path&gt; loadAll() &#123; List&lt;String&gt; query = jdbcTemplate.query(\"select file_name from file_log\", (rs,rownum) -&gt; new String(rs.getString(\"file_name\"))); return query.stream().map(filename-&gt; Paths.get(rootPath+filename)); &#125; @Override public Path load(String filename) &#123; return Paths.get(URI.create(rootPath+filename)); &#125; @Override public Resource loadAsResource(String filename) &#123; Resource resource = new FileSystemResource(rootPath+filename); if(resource.exists() &amp;&amp; resource.isFile() &amp;&amp; resource.isReadable())&#123; return resource; &#125;else&#123; throw new StorageFileNotFoundException(\"文件[\"+resource.toString()+\"]不存在\"); &#125; &#125; @Override public void deleteAll() &#123; &#125;&#125; 4.自定义异常12345678910111213package com.amose.springupload.exception;public class StorageFileNotFoundException extends RuntimeException &#123; private static final long serialVersionUID = 5162710183389028792L; public StorageFileNotFoundException() &#123; super(); &#125; public StorageFileNotFoundException(String s) &#123; super(s); &#125;&#125; 5.自定义异常12345678910111213package com.amose.springupload.exception;public class StorageFileNotFoundException extends RuntimeException &#123; private static final long serialVersionUID = 5162710183389028792L; public StorageFileNotFoundException() &#123; super(); &#125; public StorageFileNotFoundException(String s) &#123; super(s); &#125;&#125; 6.springboot消费类&emsp;&emsp;为了实验的目的,我在这里将springboot启动类与H2创建表的内容集成在一起.通过实现CommandLineRunner来建表在springboot启动后就开始执行.123456789101112131415161718192021222324252627282930ppackage com.amose.springupload;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.jdbc.core.JdbcTemplate;@SpringBootApplicationpublic class SpringUploadApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(SpringUploadApplication.class); public static void main(String[] args) &#123; SpringApplication.run(SpringUploadApplication.class, args); &#125; @Autowired private JdbcTemplate jdbcTemplate; @Override public void run(String... args)&#123; log.info(\"在内置数据库H2数据库中创建file_log表--&gt;开始\"); jdbcTemplate.execute(\"drop table file_log if exists \"); jdbcTemplate.execute(\"create table file_log (id serial,file_name VARCHAR(100),add_time TIMESTAMP)\"); log.info(\"在内置数据库H2数据库中创建file_log表--&gt;结束\"); &#125;&#125; 7.页面12345678910111213141516171819202122232425&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;body&gt;&lt;div th:if=\"$&#123;message&#125;\"&gt; &lt;h2 th:text=\"$&#123;message&#125;\"/&gt;&lt;/div&gt;&lt;div&gt; &lt;form method=\"POST\" enctype=\"multipart/form-data\" action=\"/\"&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;File to upload:&lt;/td&gt;&lt;td&gt;&lt;input type=\"file\" name=\"file\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=\"submit\" value=\"Upload\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;ul&gt; &lt;li th:each=\"file : $&#123;files&#125;\"&gt; &lt;a th:href=\"$&#123;file&#125;\" th:text=\"$&#123;file&#125;\" /&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四.结果上传前上传后下载 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之jdbcTemplate访问关系型数据库","slug":"springboot8","date":"2018-05-14T08:13:18.000Z","updated":"2018-05-14T03:26:18.093Z","comments":true,"path":"20180514/springboot8/","link":"","permalink":"amosewarrior.github.io/20180514/springboot8/","excerpt":"","text":"&emsp;&emsp;本章中,我们使用java内嵌H2数据库与JdbcTemplate来完成数据库的插入与查询.同时,在这里我们也使用了lambda表达式. 一.目标:&emsp;&emsp;通过向H2数据库插入&quot;John Woo&quot;, &quot;Jeff Dean&quot;, &quot;Josh Bloch&quot;, &quot;Josh Long&quot;,然后再查询出名为Josh的人的信息并打印出来.12Customer&#123;id=3, firstName=&apos;Josh&apos;, lastName=&apos;Bloch&apos;&#125;Customer&#123;id=4, firstName=&apos;Josh&apos;, lastName=&apos;Long&apos;&#125; 二.maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.amsoe&lt;/groupId&gt; &lt;artifactId&gt;spring-war&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;name&gt;spring-war&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- jdbc依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--H2 java内置数据库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 三.构建服务1.数据实体类&emsp;&emsp;用来存储customer表中的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.amsoe.springwar.bean;public class Customer &#123; private long id; private String firstName; private String lastName; public Customer(long id, String firstName, String lastName) &#123; this.id = id; this.firstName = firstName; this.lastName = lastName; &#125; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; @Override public String toString() &#123; return \"Customer&#123;\" + \"id=\" + id + \", firstName='\" + firstName + '\\'' + \", lastName='\" + lastName + '\\'' + '&#125;'; &#125;&#125; 2.springboot消费类&emsp;&emsp;为了实验的目的,我在这里将springboot启动类与jdbc测试内容集成在一起.通过实现CommandLineRunner来让数据库的插入和查询在springboot启动后就开始执行.12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.amsoe.springwar;import com.amsoe.springwar.bean.Customer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.jdbc.core.JdbcTemplate;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;@SpringBootApplicationpublic class JDBCApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(JDBCApplication.class); public static void main(String[] args)&#123; SpringApplication.run(JDBCApplication.class,args); &#125; @Autowired JdbcTemplate jdbcTemplate; @Override public void run(String... strings) throws Exception &#123; log.info(\"为H2内嵌式数据库创建表\"); //通过使用execute 来执行ddl操作 jdbcTemplate.execute(\"drop TABLE customer if exists\"); jdbcTemplate.execute(\"create table customer(id serial,first_name VARCHAR(255),last_name VARCHAR(255))\"); //使用lambda表达式来完成姓与名的分割 List&lt;Object[]&gt; splitUpNames = Arrays.asList(\"John Woo\", \"Jeff Dean\", \"Josh Bloch\", \"Josh Long\").stream() .map(name -&gt; name.split(\" \")) .collect(Collectors.toList()); splitUpNames.forEach(name-&gt;log.info(\"插入的名:&#123;&#125;,插入的姓:&#123;&#125;\",name[0],name[1])); //插入数据 jdbcTemplate.batchUpdate(\"insert into customer (first_name,last_name) values (?,?)\",splitUpNames); log.info(\"查询名为Josh的人的信息\"); //查询数据 List&lt;Customer&gt; query = jdbcTemplate.query(\"select * from customer where first_name = ?\", new Object[]&#123;\"Josh\"&#125;, (rs, rownum) -&gt; new Customer(rs.getLong(\"id\"), rs.getString(\"first_name\"), rs.getString(\"last_name\"))); query.forEach(customer-&gt;System.out.println(customer.toString())); &#125;&#125; 四.结果 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之restful Web Service消费","slug":"springboot7","date":"2018-05-10T08:13:18.000Z","updated":"2018-05-12T13:24:06.871Z","comments":true,"path":"20180510/springboot7/","link":"","permalink":"amosewarrior.github.io/20180510/springboot7/","excerpt":"","text":"&emsp;&emsp;当我们用springboot提供restful服务的时候,springboot也提供了接口进行服务的消费. 一.目标:&emsp;&emsp;通过向http://gturnquist-quoters.cfapps.io/api/random发送请求来进行服务的消费,消息返回如下:1234567&#123; type: \"success\", value: &#123; id: 10, quote: \"Really loving Spring Boot, makes stand alone Spring apps easy.\" &#125;&#125; 二.maven依赖1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- 嵌入式tomcat jsp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jsp jstl支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/pluginRepositories&gt; 三.构建服务1.数据实体类&emsp;&emsp;用来将json转化为我们使用的对象.12345678910111213141516171819202122232425262728293031323334package com.amsoe.springwar.bean;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;@JsonIgnoreProperties(ignoreUnknown = true)//对于未知属性进行忽略public class Quote &#123; private String type; private Value value; public Quote() &#123; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Value getValue() &#123; return value; &#125; public void setValue(Value value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Quote&#123;\" + \"type='\" + type + '\\'' + \", value=\" + value + '&#125;'; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.amsoe.springwar.bean;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;@JsonIgnoreProperties(ignoreUnknown = true)public class Value &#123; private Long id; private String quote; public Value() &#123; &#125; public Long getId() &#123; return this.id; &#125; public String getQuote() &#123; return this.quote; &#125; public void setId(Long id) &#123; this.id = id; &#125; public void setQuote(String quote) &#123; this.quote = quote; &#125; @Override public String toString() &#123; return \"Value&#123;\" + \"id=\" + id + \", quote='\" + quote + '\\'' + '&#125;'; &#125;&#125; 2.springboot消费类&emsp;&emsp;使用RestTemplate模板类进行restful服务的消费12345678910111213141516package com.amsoe.springwar.application;import com.amsoe.springwar.bean.Quote;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.client.RestTemplate;public class Application &#123; private static final Logger log = LoggerFactory.getLogger(Application.class); public static void main(String args[]) &#123; RestTemplate restTemplate = new RestTemplate(); Quote quote = restTemplate.getForObject(\"http://gturnquist-quoters.cfapps.io/api/random\", Quote.class); log.info(quote.toString()); &#125;&#125; 四.结果 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之JSP使用","slug":"springboot6","date":"2018-05-10T06:13:18.000Z","updated":"2018-05-10T08:36:45.272Z","comments":true,"path":"20180510/springboot6/","link":"","permalink":"amosewarrior.github.io/20180510/springboot6/","excerpt":"","text":"&emsp;&emsp;springboot 推荐使用Thymeleaf,但是由于jsp的根深蒂固,所以要操作一波. 一.目标:&emsp;&emsp;通过访问http://localhost:8080/index来访问位于/WEB-INF/jsp/index.jsp页面 二.maven依赖1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- 嵌入式tomcat jsp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jsp jstl支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/pluginRepositories&gt; 三.构建服务1.springboot 启动类&emsp;&emsp;需要注意的是:启动类请放在com.amose目录下.12345678910111213package com.amose;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableScheduling//启用定时任务组件public class T1SpringBootApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(T1SpringBootApplication.class,args); &#125;&#125; 2.springmvc前后缀配置在resource下的application.properties中添加12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 四.结果 在springboot中内置了servlet容器的,所以只要添加jsp和jstl的依赖就能使用jsp页面了. 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之Cron表达式","slug":"springboot5","date":"2018-05-07T08:13:18.000Z","updated":"2018-05-07T08:21:41.810Z","comments":true,"path":"20180507/springboot5/","link":"","permalink":"amosewarrior.github.io/20180507/springboot5/","excerpt":"","text":"文章转载于cron表达式详解 &emsp;&emsp;Cron表达式在quartz和spring定时任务中都有使用到,用来设置任务执行时间执行间隔. 一.结构:&emsp;&emsp;cron表达式的结构如下:1corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 二.各字段的含义 字段 允许值 允许特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： （1）：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 ?, 其中最后一位只能用？，而不能使用，如果使用*表示不管星期几都会触发，实际上并不是这样。 （3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 （6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 （7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。 （8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 （9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 三.常用表达式例子 （1）0 0 2 1 ? 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 ? 每天中午12点触发 （8）0 15 10 ? 每天上午10:15触发 （9）0 15 10 ? 每天上午10:15触发 （10）0 15 10 ? * 每天上午10:15触发 （11）0 15 10 ? 2005 2005年的每天上午10:15触发 （12）0 14 * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 四.注意事项（1）有些子表达式能包含一些范围或列表 例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT” “*”字符代表所有可能的值 因此，“”在子表达式（月）里表示每个月的含义，“”在子表达式（天（星期））表示星期的每一天 “/”字符用来指定数值的增量 例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样 “？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？” “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 但是它在两个子表达式里的含义是不同的。 在天（月）子表达式中，“L”表示一个月的最后一天 在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT 如果在“L”前有具体的内容，它就具有其他的含义了 例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之Schedule定时任务","slug":"springboot4","date":"2018-05-07T06:13:18.000Z","updated":"2018-05-07T05:30:13.096Z","comments":true,"path":"20180507/springboot4/","link":"","permalink":"amosewarrior.github.io/20180507/springboot4/","excerpt":"","text":"&emsp;&emsp;用maven+springboot搭建一个简单的定时任务. 一.目标:&emsp;&emsp;通过@Scheduled注解来完成每五秒打印一次当前时间 二.maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 三.构建服务1.定时任务类123456789101112131415161718192021package com.amose.controller;import com.amose.bean.Greeting;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicLong;@RestControllerpublic class GreetingController &#123; private static final String template = \"Hello, %s!\"; private final AtomicLong counter = new AtomicLong(); @RequestMapping(\"/greeting\") public Greeting greeting(@RequestParam(value=\"name\", defaultValue=\"World\") String name)&#123; Greeting g = new Greeting(); g.setId(counter.getAndIncrement()); g.setContent(String.format(template,name)); return g; &#125;&#125; 2.springboot 启动类&emsp;&emsp;需要注意的是:启动类请放在com.amose目录下.12345678910111213package com.amose;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableScheduling//启用定时任务组件public class T1SpringBootApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(T1SpringBootApplication.class,args); &#125;&#125; 3.@Scheduled参数1.cron:cron表达式参考cron表达式2.zone:@Scheduled(fixedDelay = 5000 ,zone = “Asia/Colombo”) 指定时区3.fixedDelay:@Scheduled(fixedDelay=5000)上一次任务执行完成后5秒再次执行4.fixedDelayString:@Scheduled(fixedDelay=5000)上一次任务执行完成后5秒再次执行5.fixedRate:@Scheduled(fixedRate=5000)上一次开始执行时间点后5秒再次执行6.fixedRateString:@Scheduled(fixedRateString=”5000”)上一次开始执行时间点后5秒再次执行7.initialDelay:@Scheduled(initialDelay=1000, fixedDelay=2000)：第一次延迟1秒执行，然后在上一次执行完毕时间点后2秒再次执行；8:initialDelayString:@Scheduled(initialDelayString=”1000”, fixedDelay=2000)：第一次延迟1秒执行，然后在上一次执行完毕时间点后2秒再次执行； 四.结果 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之Unsupported major.minor version 52.0(idea版)","slug":"springboot3","date":"2018-05-01T03:13:18.000Z","updated":"2018-05-04T04:07:22.282Z","comments":true,"path":"20180501/springboot3/","link":"","permalink":"amosewarrior.github.io/20180501/springboot3/","excerpt":"","text":"&emsp;&emsp;在进行springboot demo启动时,出现了Unsupported major.minor version 52.0 的错误.这是因为springboot的需求版本跟java的目标版本不一致.共需要修改两个地方.","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之Restful Web Service","slug":"springboot2","date":"2018-04-28T03:13:18.000Z","updated":"2018-05-07T01:55:10.105Z","comments":true,"path":"20180428/springboot2/","link":"","permalink":"amosewarrior.github.io/20180428/springboot2/","excerpt":"","text":"&emsp;&emsp;用maven+springboot搭建一个简单的restful web service. 一.目标:在这里会创建一个服务,接收如下请求1http://localhost:8080/greeting 并返回如下的json对象.1&#123;&quot;id&quot;:&quot;1&quot;,&quot;content&quot;:&quot;Hello World&quot;&#125; 当然,在上面请求中,我们也可以添加参数1http://localhost:8080/greeting?name=yang 然后返回结果为1&#123;&quot;id&quot;:&quot;1&quot;,&quot;content&quot;:&quot;Hello yang&quot;&#125; 二.maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 三.构建服务1.bean&emsp;&emsp;利用json工具自动将Greeting类转为json123456789101112131415161718192021package com.amose.bean;public class Greeting &#123; private String id; private String content; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 2.restful接口类123456789101112131415161718192021package com.amose.controller;import com.amose.bean.Greeting;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicLong;@RestControllerpublic class GreetingController &#123; private static final String template = \"Hello, %s!\"; private final AtomicLong counter = new AtomicLong(); @RequestMapping(\"/greeting\") public Greeting greeting(@RequestParam(value=\"name\", defaultValue=\"World\") String name)&#123; Greeting g = new Greeting(); g.setId(counter.getAndIncrement()); g.setContent(String.format(template,name)); return g; &#125;&#125; 3.springboot 启动类&emsp;&emsp;需要注意的是:启动类请放在com.amose目录下.1234567891011package com.amose;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class T1SpringBootApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(T1SpringBootApplication.class,args); &#125;&#125; 四.结果 纸上得来终觉浅,绝知此事要躬行","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot之SocialConfigurerAdapter.class cannot be opened because it does not exist","slug":"springboot1","date":"2018-04-23T03:13:18.000Z","updated":"2018-05-04T04:07:00.717Z","comments":true,"path":"20180423/springboot1/","link":"","permalink":"amosewarrior.github.io/20180423/springboot1/","excerpt":"","text":"&emsp;&emsp;用maven搭建了一个springboot的小demo,然后在启动是报如下错误:1234567891011121314151617Caused by: java.io.FileNotFoundException: class path resource [org/springframework/social/config/annotation/SocialConfigurerAdapter.class] cannot be opened because it does not exist at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:172) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReader.&lt;init&gt;(SimpleMetadataReader.java:50) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:98) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.createMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:89) ~[spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE] at org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.getMetadataReader(ConcurrentReferenceCachingMetadataReaderFactory.java:76) ~[spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE] at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:93) ~[spring-core-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.asSourceClass(ConfigurationClassParser.java:693) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getSuperClass(ConfigurationClassParser.java:857) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:328) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:190) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:292) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:198) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:167) ~[spring-context-4.3.8.RELEASE.jar:4.3.8.RELEASE] ... 13 common frames omitted 找了半天,发现前面有个警告. 发现是启动类不应该放在在顶级包下.然后加了个包就行了.","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/categories/SpringBoot/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"amosewarrior.github.io/tags/SpringBoot/"}]},{"title":"lombok之注解使用","slug":"lombok2","date":"2018-04-21T03:13:18.000Z","updated":"2018-05-04T04:06:51.292Z","comments":true,"path":"20180421/lombok2/","link":"","permalink":"amosewarrior.github.io/20180421/lombok2/","excerpt":"","text":"一.lombok对象与注解&emsp;&emsp;lombok 通过注解和定义对象来简化代码的书写.比如val 用于定义局部finnal变量.var 用于定义局部动态变量.@NonNull 进行非空判断. 二.demo的依赖包&emsp;&emsp;使用lombok时除了要使用lombok插件外还需要添加lombok的依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.12&lt;/version&gt;&lt;/dependency&gt; 三.val 局部finally变量&emsp;&emsp; 利用val替代实际final变量的声明,让lombok自动根据赋值表达式来替换val.替换的好处就是不需要自己判定赋值表达式返回的数据类型,当然源代码长度也缩减了. lombok的目的也就是为了减少冗余代码.1234567891011121314151617import lombok.val;import java.util.ArrayList;/** * @author yp * @time 2018/4/13 * @description 可以用val替代局部final变量的实际声明.由val代替的声明 */public class TestVal &#123; public static void main(String[] args)&#123; val list = new ArrayList&lt;String&gt;(); //等同于ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"0\"); list.add(\"1\"); System.out.println(list.get(0)); list = new ArrayList&lt;String&gt;(); &#125;&#125; 四.var 局部变量&emsp;&emsp; var这个对象其实目前还处于实验阶段,所以在使用var时需要注意,需要现在lombok.config中声明: lombok.var.flagUsage = ALLOW &emsp;&emsp; 这样lombok插件才会去读取由var标注的变量,并进行转换.123456789101112131415161718import lombok.experimental.var;import java.util.ArrayList;/** * @author yp * @time 2018/4/16 * @description */public class TestVar &#123; public static void main(String[] args)&#123; var s = new ArrayList&lt;String&gt;(); s.add(\"aaa\"); s.add(\"bbb\"); System.out.println(\"==&gt;\"+s.get(0)); s = new ArrayList&lt;String&gt;(); s.add(\"cccc\"); System.out.println(\"==&gt;\"+s.get(0)); &#125;&#125; &emsp;&emsp; 这里需要注意的是,请将lombok.config放在src下,而不是resources下,编译优于合并. 五.@NonNull 注解&emsp;&emsp; 在构造方法或者放入入参时,在所有方法体代码内的顶层进行对参数进行null判断(但是,super()和this()会比它先执行).1234567891011121314151617181920212223242526272829303132333435363738394041424344import lombok.NonNull;/** * @author yp * @time 2018/4/20 * @description */public class TestNonNull extends Something&#123; public TestNonNull(@NonNull String s) &#123; super(\"Hello1\"); System.out.println(s); &#125; private TestNonNull(Integer s) &#123; super(\"Hello2\"); if(s == null)&#123; throw new NullPointerException(\"normal\"); &#125; System.out.println(s); &#125; public static void main(String[] args)&#123; String s = null; TestNonNull t1 = new TestNonNull(s); Integer a = null; TestNonNull t2 = new TestNonNull(a); &#125;&#125;/** * @author yp * @time 2018/4/20 * @description */public class Something &#123; public Something(String s)&#123; System.out.println(s); &#125; public Something(Integer s)&#123; System.out.println(s); &#125;&#125; 从代码和上图可以看出,@NonNull 是在构造方法的super()方法之后进行null检查的,跟if(s == null)效果一致. 六.@Cleanup 资源释放&emsp;&emsp;@Cleanup是用来对局部变量所占用的资源进行自动释放的.比如输入,输出流.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.Cleanup;import java.io.*;/** * @author yp * @time 2018/4/23 * @description Cleanup 用于自动结束使用的资源. */public class TestCleanUp &#123; public static void main(String[] args) throws IOException &#123; String[] s = new String[2]; s[0] = &quot;D:/SQLWork.txt&quot;; s[1] = &quot;D:/SQLWork1.txt&quot;; File file = new File(s[1]); //在执行main1的时候,没有进行流的关闭,文件会被占用,这里进行删除操作会返回false main1(s); boolean d1 = file.delete(); System.out.println(&quot;无Cleanup注解===&gt;&quot;+d1); //在执行main2方法时,请注释main1的代码,避免main1的流未关闭造成文件被占用 //在执行main2的时候,通过Cleanup进行流的关闭,这里进行删除操作会返回true main2(s); boolean d2= file.delete(); System.out.println(&quot;有Cleanup注解===&gt;&quot;+d2); &#125; public static void main1(String[] args) throws IOException &#123; InputStream in = new FileInputStream(args[0]); OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125; public static void main2(String[] args) throws IOException &#123; @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[1024]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125;&#125; 七.@Getter@Setter 1.@Getter @Setter可以放在类上,对类的成员变量进行get,set方法的生成,也可以放在指定成员变量上.123456789import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private String username; private String password;&#125; 2.通过AccessLevel设定成员变量生成的Get和set方法的访问级别,PUBLIC, PROTECTED, PACKAGE,PRIVATE123456789import lombok.AccessLevel;import lombok.Getter;public class User1 &#123; @Getter(AccessLevel.PROTECTED)// private String username; @Getter(AccessLevel.NONE)//禁止get,set方法生成 private String password;&#125; 八.@ToString 生成toString方法&emsp;&emsp;类上添加@ToString方法,进行toString方法的生成,通过exclude=””来进行指定属性的排除123456789101112131415161718import lombok.Getter;import lombok.Setter;import lombok.ToString;/** * @author yp * @time 2018/4/23 * @description */@ToString(exclude = &quot;password&quot;)@Getter@Setterpublic class User3 &#123; private String username; private String password; private String sex;&#125; 九.@EqualsAndHashCode&emsp;&emsp;重写equal和hashcode 方法.通过exclude={“id”, “shape”}来排除指定属性.通过callSuper=true来对父类成员变量的生成.12345678910111213141516171819202122232425import lombok.EqualsAndHashCode;@EqualsAndHashCode(exclude=&#123;&quot;id&quot;, &quot;shape&quot;&#125;)public class EqualsAndHashCodeExample &#123; private transient int transientVar = 10; private String name; private double score; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() &#123; return this.name; &#125; @EqualsAndHashCode(callSuper=true) public static class Square extends Shape &#123; private final int width, height; public Square(int width, int height) &#123; this.width = width; this.height = height; &#125; &#125;&#125; 十.构造注解&emsp;&emsp;@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor 分别是:无参构造,指定有参构造(被@NonNull标记),所有构造1234567891011121314151617import lombok.AccessLevel;import lombok.RequiredArgsConstructor;import lombok.AllArgsConstructor;import lombok.NonNull;@RequiredArgsConstructor(staticName = &quot;of&quot;)@AllArgsConstructor(access = AccessLevel.PROTECTED)public class ConstructorExample&lt;T&gt; &#123; private int x, y; @NonNull private T description; @NoArgsConstructor public static class NoArgsExample &#123; @NonNull private String field; &#125;&#125;` 十一.@Data&emsp;&emsp;是@ToString, @EqualsAndHashCode, @Getter 所有属性, @Setter 所有非final属性,和@RequiredArgsConstructor的合集,lombok中最为常用的注解. 十二.@Value&emsp;&emsp;@Value 是@Data的final类,属性也是final的.当然用@Wither注解的属性不是final的.1234567891011121314151617181920 import lombok.AccessLevel;import lombok.experimental.NonFinal;import lombok.experimental.Value;import lombok.experimental.Wither;import lombok.ToString;@Value public class ValueExample &#123; String name; @Wither(AccessLevel.PACKAGE) @NonFinal int age; double score; protected String[] tags; @ToString(includeFieldNames=true) @Value(staticConstructor=&quot;of&quot;) public static class Exercise&lt;T&gt; &#123; String name; T value; &#125;&#125; 十三.@Log通过不同的注解生成不同类型的log变量.这个在lombok中也是比较实用的1234567891011121314@CommonsLogCreates private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);@JBossLogCreates private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);@LogCreates private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());@Log4jCreates private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);@Log4j2Creates private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);@Slf4jCreates private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);@XSlf4jCreates private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 1234567891011121314151617181920212223@Logpublic class LogExample &#123; public static void main(String... args) &#123; log.error(&quot;Something&apos;s wrong here&quot;); &#125;&#125;@Slf4jpublic class LogExampleOther &#123; public static void main(String... args) &#123; log.error(&quot;Something else is wrong here&quot;); &#125;&#125;@CommonsLog(topic=&quot;CounterLog&quot;)public class LogExampleCategory &#123; public static void main(String... args) &#123; log.error(&quot;Calling the &apos;CounterLog&apos; with a message&quot;); &#125;&#125; 十四.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"lombok之插件安装(idea版)","slug":"lombok1","date":"2018-04-20T03:13:18.000Z","updated":"2018-05-04T04:04:45.432Z","comments":true,"path":"20180420/lombok1/","link":"","permalink":"amosewarrior.github.io/20180420/lombok1/","excerpt":"","text":"一.主题简介&emsp;&emsp;lombok是一个通过注解来减少模板代码的插件,其作用于编译期,网上都是这么说的:就是源代码在编译成字节码的时候修改了语法树的节点规则进行了加强生成.在我的理解就是在编译的时候将被注解的地方生成对应注解的模板代码.就跟代码生成器一样,只不过lombok生成的是字节码,我们生成的是java源码.介绍到这,我们开始安装~ 二.安装插件&emsp;&emsp;找到配置下的插件管理器,点击插件仓库搜索lombok进行安装:File-&gt;Settings-&gt;Plugins 三.配置&emsp;&emsp;配置编译器的属性,勾选使用注解处理,然后重启idea.File-&gt;Settings-&gt;Build-&gt;Compiler-&gt;Annotation Processors 四.踩坑检测&emsp;&emsp;在安装插件的时候踩了两个坑.坑1:编译器使用的Eclipse,导致lombok插件无法使用.改成javac,并去掉使用模块的jdk选项坑2:若要使用lombok.config配置参数.请不要放在resources文件夹下,放在src包下,不然编译无法时是读取不到的. 五.总结&emsp;&emsp;看着挺简单的东西,在真正去实践的时候你才会发现事实永远不会像我们想象的那么简单.谨记墨菲定律：一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四、如果你担心某种情况发生，那么它就更有可能发生","categories":[{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/categories/lombok/"}],"tags":[{"name":"java","slug":"java","permalink":"amosewarrior.github.io/tags/java/"},{"name":"lombok","slug":"lombok","permalink":"amosewarrior.github.io/tags/lombok/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-18T00:55:29.125Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"20180418/hello-world/","link":"","permalink":"amosewarrior.github.io/20180418/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}